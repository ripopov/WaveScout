#!/usr/bin/env python3
"""
This script generates a VCD file with many sine–wave signals organized in a
4–level hierarchy. The top–level module (“top”) contains a binary clock and reset.
Below, submodules (arranged in a 3–level hierarchy) each hold a few sine signals.
For this demo, the default parameters generate:
  - 8 leaf modules (arranged as 2×2×2),
  - 2 sine signals per leaf module,
  - a simulation time of 0.001 ms (1e6 ps),
  - a clock frequency of 1 GHz,
  - and sine signals sampled every 1000 ps.

Example command line:
    python3 vcd_generator.py --modules 8 --signals-per-module 2 --sim-ms 0.001 --clock-freq 1e9 --sine-sample-ps 1000

WARNING: Using larger parameters (for example, 1000 modules with 10 signals each
over 1 ms) will generate a huge VCD file and may run very slowly.
"""

import argparse
import math
import random
import sys


# ===============================
# Utility functions for VCD IDs
# ===============================
# We use printable ASCII characters from "!" (33) to "~" (126).
def encode_id(n):
    # Encode integer n in base-94 (using characters 33..126)
    chars = []
    while True:
        chars.append(chr(33 + (n % 94)))
        n //= 94
        if n == 0:
            break
    return "".join(chars)


class IdGenerator:
    def __init__(self):
        self.next = 0

    def get(self):
        id_str = encode_id(self.next)
        self.next += 1
        return id_str


# ===============================
# Helper to format frequency values.
# ===============================
def format_frequency(freq):
    """
    Format the frequency value into a string with units.
    If the frequency is less than 1e3, use Hz.
    If less than 1e6, use kHz.
    If less than 1e9, use MHz.
    Otherwise, use GHz.
    """
    if freq < 1e3:
        return f"{freq:.0f}hz"
    elif freq < 1e6:
        return f"{freq / 1e3:.0f}khz"
    elif freq < 1e9:
        return f"{freq / 1e6:.0f}mhz"
    else:
        return f"{freq / 1e9:.0f}ghz"


# ===============================
# Main function
# ===============================
def main():
    parser = argparse.ArgumentParser(description="Generate a VCD file with many sinewave signals (demo defaults).")
    parser.add_argument("--modules", type=int, default=8,
                        help="Total number of leaf modules (default: 8). "
                             "Leaf modules are arranged in a 3-level hierarchy (e.g. 2x2x2).")
    parser.add_argument("--signals-per-module", type=int, default=2,
                        help="Number of sine signals per leaf module (default: 2).")
    parser.add_argument("--sim-ms", type=float, default=0.001,
                        help="Total simulation time in milliseconds (default: 0.001).")
    parser.add_argument("--clock-freq", type=float, default=1e9,
                        help="Clock frequency in Hz (default: 1e9).")
    parser.add_argument("--sine-sample-ps", type=int, default=1000,
                        help="Sine-signal sampling interval in picoseconds (default: 1000).")
    parser.add_argument("--outfile", type=str, default="genout.vcd",
                        help="Output VCD filename (default: genout.vcd)")
    args = parser.parse_args()

    # --- Simulation parameters ---
    # Total simulation time in picoseconds. (1 ms = 1e-3 s = 1e-3*1e12 ps = 1e9 ps)
    SIM_TIME_PS = int(args.sim_ms * 1e9)
    # For a clock of frequency F Hz, period T = 1/F seconds.
    # In picoseconds, period_ps = 1/F * 1e12. For a 1 GHz clock, period_ps = 1e12/1e9 = 1000 ps.
    # To get a square wave, we toggle every half–period.
    CLOCK_HALF_PERIOD_PS = int((1 / args.clock_freq / 2) * 1e12)
    # Sine signals are updated every SINE_SAMPLE_INTERVAL_PS picoseconds.
    SINE_SAMPLE_INTERVAL_PS = args.sine_sample_ps

    # --- Hierarchy parameters ---
    # We want a 4-level hierarchy: top ("top") then 3 levels of submodules.
    # The number of leaf modules = (level_count)^3.
    levels = 3
    level_count = int(round(args.modules ** (1 / levels)))
    total_leaf = level_count ** levels
    if total_leaf != args.modules:
        sys.stderr.write(f"Warning: With {args.modules} modules requested, "
                         f"arranging in a {level_count}x{level_count}x{level_count} tree gives {total_leaf} modules.\n")

    # --- Prepare to write file ---
    id_gen = IdGenerator()
    outfile = open(args.outfile, "w")

    def writeln(line=""):
        outfile.write(line + "\n")

    # Write VCD header
    writeln("$date")
    writeln("    " + "Generated by Python VCD Generator (demo defaults)")
    writeln("$end")
    writeln("$version")
    writeln("    " + "Python VCD Generator")
    writeln("$end")
    writeln("$timescale")
    writeln("    1ps")
    writeln("$end")

    # --- Begin top-level scope ---
    writeln("$scope module top $end")

    # --- Top-level signals: clock and reset ---
    clk_id = id_gen.get()
    rst_id = id_gen.get()
    writeln(f"$var wire 1 {clk_id} clk $end")
    writeln(f"$var wire 1 {rst_id} rst $end")
    # We store the top-level clock and reset info for simulation.
    top_signals = {
        "clk": {"id": clk_id, "name": "clk", "bitwidth": 1, "last": 0, "type": "clock"},
        "rst": {"id": rst_id, "name": "rst", "bitwidth": 1, "last": 1, "type": "reset"}
        # assume reset is high initially
    }

    # --- Prepare list for sine signals (will be added in leaf modules) ---
    sine_signals = []  # each entry is a dict with keys: id, name, bitwidth, freq, amp, phase, last

    # Global module counter so that each submodule gets a unique name.
    module_counter = 0

    # --- Recursive function to write module hierarchy ---
    def write_module(level, max_level):
        nonlocal module_counter
        if level < max_level:
            # Create submodules at this level.
            for i in range(level_count):
                mod_name = f"sub{module_counter}"
                module_counter += 1
                writeln(f"$scope module {mod_name} $end")
                write_module(level + 1, max_level)
                writeln("$upscope $end")
        else:
            # Leaf module: define the sine signals using local names augmented with frequency.
            for s in range(args.signals_per_module):
                # Generate a random frequency.
                # (Change the range here if you want frequencies that might be in the GHz range.)
                freq = random.uniform(1e3, 1e7)  # frequency between 1 kHz and 10 MHz
                # Format the frequency string.
                freq_str = format_frequency(freq)
                # The local signal name now includes the frequency.
                sig_name = f"s{s}_{freq_str}"
                bitwidth = random.randint(4, 32)
                amp = 0.5 + 0.5 * random.random()  # amplitude factor between 0.5 and 1.0
                phase = random.uniform(0, 2 * math.pi)
                sig_id = id_gen.get()
                writeln(f"$var wire {bitwidth} {sig_id} {sig_name} $end")
                sine_signals.append({
                    "id": sig_id,
                    "name": sig_name,
                    "bitwidth": bitwidth,
                    "freq": freq,
                    "amp": amp,
                    "phase": phase,
                    "last": None  # to be computed later
                })

    # Build the hierarchy (top-level already opened).
    write_module(0, levels)
    writeln("$upscope $end")  # End of top-level scope.
    writeln("$enddefinitions $end")

    # --- Dump initial values ---
    writeln("#0")
    writeln("$dumpvars")
    # Top-level signals (clock and reset).
    writeln(f"0{top_signals['clk']['id']}")
    writeln(f"1{top_signals['rst']['id']}")

    # For each sine signal, compute its initial (t=0) quantized value.
    for sig in sine_signals:
        t_sec = 0.0  # time in seconds (1 ps = 1e-12 s)
        val = int(((sig["amp"] * math.sin(2 * math.pi * sig["freq"] * t_sec + sig["phase"]) + 1) / 2) * (
                    (2 ** sig["bitwidth"]) - 1))
        sig["last"] = val
        if sig["bitwidth"] == 1:
            writeln(f"{val}{sig['id']}")
        else:
            bin_str = format(val, "b")
            writeln(f"b{bin_str} {sig['id']}")
    writeln("$end")

    # --- Simulation loop ---
    #
    # Two event streams are merged:
    #   (a) Clock events every CLOCK_HALF_PERIOD_PS (to toggle the clock).
    #   (b) Sine signal sampling events every SINE_SAMPLE_INTERVAL_PS.
    #
    next_clock_time = 0
    current_clk_val = top_signals["clk"]["last"]
    sine_times = list(range(0, SIM_TIME_PS + 1, SINE_SAMPLE_INTERVAL_PS))
    sine_idx = 0

    while next_clock_time <= SIM_TIME_PS or sine_idx < len(sine_times):
        # Determine the next event time.
        next_sine_time = sine_times[sine_idx] if sine_idx < len(sine_times) else SIM_TIME_PS + 1
        current_time = min(next_clock_time, next_sine_time)
        writeln(f"#{current_time}")

        # Clock event: toggle clock.
        if next_clock_time == current_time:
            current_clk_val = 1 - current_clk_val
            writeln(f"{current_clk_val}{top_signals['clk']['id']}")
            next_clock_time += CLOCK_HALF_PERIOD_PS

        # Sine sampling event: update sine signals if their value changes.
        if sine_idx < len(sine_times) and next_sine_time == current_time:
            t_sec = current_time * 1e-12  # convert ps to seconds
            for sig in sine_signals:
                new_val = int(((sig["amp"] * math.sin(2 * math.pi * sig["freq"] * t_sec + sig["phase"]) + 1) / 2)
                              * ((2 ** sig["bitwidth"]) - 1))
                if new_val != sig["last"]:
                    sig["last"] = new_val
                    if sig["bitwidth"] == 1:
                        writeln(f"{new_val}{sig['id']}")
                    else:
                        bin_str = format(new_val, "b")
                        writeln(f"b{bin_str} {sig['id']}")
            sine_idx += 1

    outfile.close()
    print(f"VCD file written to {args.outfile}")


if __name__ == "__main__":
    main()

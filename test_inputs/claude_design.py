#!/usr/bin/env python3
"""
Generate a VCD file for a complex processor design with hierarchical structure.
Creates 200K variables across 10 levels of nested scopes for benchmarking.
Each variable updates at a different frequency with random values.
Generated by Claude for WaveScout performance testing.
"""

import math
import sys
import argparse
import random
from datetime import datetime


def encode_id(n):
    """Encode a number as a VCD identifier using printable ASCII characters."""
    chars = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    if n == 0:
        return chars[0]
    
    result = ""
    while n > 0:
        result = chars[n % len(chars)] + result
        n //= len(chars)
    return result


class RISCDesignGenerator:
    def __init__(self, filename="design_claude.vcd", clock_count=10000):
        self.filename = filename
        self.clock_count = clock_count
        self.file = None
        self.var_counter = 0
        self.total_vars = 0
        self.signals = []
        self.clock_signals = []  # Track clock signals for aliases
        self.signal_update_cycles = {}  # Track when each signal should update
        
    def open_file(self):
        """Open the VCD file for writing."""
        self.file = open(self.filename, 'w')
        
    def close_file(self):
        """Close the VCD file."""
        if self.file:
            self.file.close()
            
    def write_line(self, line=""):
        """Write a line to the VCD file."""
        if self.file:
            self.file.write(line + "\n")
        
    def write_header(self):
        """Write the VCD header section."""
        self.write_line("$date")
        self.write_line(f"    {datetime.now().strftime('%a %b %d %H:%M:%S %Y')}")
        self.write_line("$end")
        self.write_line("$version")
        self.write_line("    Claude Design VCD Generator for WaveScout Benchmarking")
        self.write_line("$end")
        self.write_line("$timescale")
        self.write_line("    1ps")
        self.write_line("$end")
        
    def generate_signal_name(self, prefix, index, signal_type):
        """Generate a meaningful signal name based on type."""
        suffixes = {
            'clock': ['clk', 'clock', 'sclk', 'mclk', 'pclk'],
            'data': ['data', 'd', 'din', 'dout', 'q'],
            'control': ['en', 'rst', 'valid', 'ready', 'ack'],
            'address': ['addr', 'adr', 'pc', 'sp', 'ptr'],
            'bus': ['bus', 'dbus', 'abus', 'ibus', 'xbus'],
            'analog': ['vdd', 'vss', 'vref', 'iout', 'temp']
        }
        
        suffix_list = suffixes.get(signal_type, ['sig'])
        suffix = suffix_list[index % len(suffix_list)]
        return f"{prefix}_{suffix}_{index}"
        
    def create_scope_signals(self, scope_path, level, max_vars_in_scope):
        """Create signals for a specific scope."""
        # Limit the number of variables per scope for performance
        vars_in_scope = min(max_vars_in_scope, 1000)  # Cap at 1000 per scope for efficiency
        
        if vars_in_scope < 10:
            vars_in_scope = 10  # Minimum signals per scope
            
        signals_created = []
        
        # Create mix of signal types
        signal_distribution = [
            ('clock', 0.05),    # 5% clocks
            ('data', 0.30),     # 30% data signals
            ('control', 0.15),  # 15% control signals
            ('address', 0.10),  # 10% address signals
            ('bus', 0.25),      # 25% buses
            ('analog', 0.15)    # 15% analog signals
        ]
        
        for sig_type, ratio in signal_distribution:
            count = int(vars_in_scope * ratio)
            if count == 0 and sig_type == 'clock':
                count = 1  # At least one clock per scope
                
            for i in range(count):
                sig_name = self.generate_signal_name(scope_path.replace('/', '_'), i, sig_type)
                sig_id = encode_id(self.var_counter)
                self.var_counter += 1
                
                # Determine signal properties based on type
                if sig_type == 'clock':
                    var_type = 'wire'
                    bitwidth = 1
                    # Different clock frequencies
                    freq_options = [1e9, 500e6, 250e6, 125e6, 100e6, 50e6, 25e6, 10e6]
                    frequency = freq_options[i % len(freq_options)]
                    is_clock = True
                elif sig_type == 'analog':
                    var_type = 'real'
                    bitwidth = 64
                    frequency = random.uniform(1e3, 1e6)  # Analog signal frequencies
                    is_clock = False
                elif sig_type == 'bus':
                    var_type = 'reg'
                    # Various bus widths
                    bus_widths = [8, 16, 32, 64, 128, 256]
                    bitwidth = bus_widths[i % len(bus_widths)]
                    frequency = random.uniform(1e6, 100e6)
                    is_clock = False
                elif sig_type == 'address':
                    var_type = 'reg'
                    bitwidth = 32  # Standard address width
                    frequency = random.uniform(10e6, 500e6)
                    is_clock = False
                else:  # data, control
                    var_type = random.choice(['reg', 'wire', 'integer'])
                    if var_type == 'integer':
                        bitwidth = 32
                    else:
                        bitwidth = random.choice([1, 2, 4, 8, 16, 32])
                    frequency = random.uniform(1e6, 1e9)
                    is_clock = False
                    
                # Write variable declaration
                self.write_line(f"$var {var_type} {bitwidth} {sig_id} {sig_name} $end")
                
                # Store signal info
                signal_info = {
                    'id': sig_id,
                    'name': sig_name,
                    'var_type': var_type,
                    'bitwidth': bitwidth,
                    'frequency': frequency,
                    'phase': random.uniform(0, 2 * math.pi),
                    'is_clock': is_clock,
                    'signal_type': sig_type,
                    'level': level,
                    'scope': scope_path,
                    'update_interval': random.randint(1, 100),  # Update every 1-100 clocks for more varied frequencies
                    'last_update_cycle': random.randint(-100, 0)  # Random initial offset for staggered updates
                }
                
                signals_created.append(signal_info)
                self.signals.append(signal_info)
                
                if is_clock:
                    self.clock_signals.append(signal_info)
                    signal_info['update_interval'] = 1  # Clocks always update every cycle
                    
                self.total_vars += 1
                
        return signals_created
        
    def create_hierarchical_structure(self, current_scope, level, max_level, path="", remaining_vars=200000):
        """Recursively create hierarchical module structure."""
        if level > max_level or remaining_vars <= 0:
            return remaining_vars
            
        # Module names based on typical RISC processor components
        module_types = [
            'core', 'alu', 'decoder', 'regfile', 'cache', 'mmu', 'fpu',
            'bpu', 'lsu', 'scheduler', 'rob', 'issue', 'fetch', 'execute',
            'memory', 'writeback', 'arbiter', 'controller', 'datapath', 'pipeline'
        ]
        
        # Calculate target variables per level to reach 200K total
        # Distribute more evenly to avoid creating too many at once
        if level == 1:
            vars_at_this_level = min(10000, remaining_vars // 10)  # Top level gets fewer
        else:
            vars_at_this_level = min(50000, remaining_vars // (11 - level))
        
        # Create signals in current scope
        prev_total = self.total_vars
        self.create_scope_signals(path if path else "top", level, vars_at_this_level)
        vars_created = self.total_vars - prev_total
        remaining_vars -= vars_created
        
        # Create child modules
        if level < max_level and remaining_vars > 0:
            # Number of child modules decreases with depth
            num_children = max(2, min(5, 7 - level))  # Limit children to control explosion
            
            for i in range(num_children):
                if remaining_vars <= 0:
                    break
                    
                module_type = module_types[(level * 10 + i) % len(module_types)]
                module_name = f"{module_type}_{level}_{i}"
                child_path = f"{path}/{module_name}" if path else module_name
                
                self.write_line(f"$scope module {module_name} $end")
                remaining_vars = self.create_hierarchical_structure(module_name, level + 1, max_level, child_path, remaining_vars)
                self.write_line("$upscope $end")
                
        return remaining_vars
                
    def create_clock_aliases(self):
        """Create aliases for clock signals to simulate clock distribution networks."""
        # Only create aliases for actual clock signals
        for i, clock_sig in enumerate(self.clock_signals[:100]):  # Limit aliases to prevent excessive duplication
            # Create 2-3 aliases per clock to simulate distribution
            num_aliases = random.randint(2, 3)
            for j in range(num_aliases):
                alias_id = encode_id(self.var_counter)
                self.var_counter += 1
                alias_name = f"{clock_sig['name']}_alias_{j}"
                
                # Use the same ID for the alias (pointing to same signal)
                self.write_line(f"$var {clock_sig['var_type']} {clock_sig['bitwidth']} {alias_id} {alias_name} {clock_sig['id']} $end")
                
    def write_signal_definitions(self):
        """Write all signal definitions with hierarchical structure."""
        self.write_line("$scope module top $end")
        
        # Create 10 levels of hierarchy with 200K target
        target_vars = 200000  # Target 200K variables for benchmarking
        self.create_hierarchical_structure("top", 1, 10, "", target_vars)
        
        # Add clock aliases at the top level (skip for now to speed up)
        # self.create_clock_aliases()
        
        self.write_line("$upscope $end")
        self.write_line("$enddefinitions $end")
        
        print(f"Created {self.total_vars} unique variables across 10 scope levels")
        print(f"Created {len(self.clock_signals)} clock signals")
        
    def calculate_signal_value(self, signal, time_ps):
        """Calculate signal value at given time - always returns random values."""
        time_sec = time_ps * 1e-12
        
        if signal['is_clock']:
            # Simple square wave for clocks
            period = 1.0 / signal['frequency']
            phase_time = time_sec + signal['phase'] / (2 * math.pi * signal['frequency'])
            return 1 if (phase_time % period) < (period / 2) else 0
            
        elif signal['var_type'] == 'real':
            # Analog signals - fully random values
            return random.uniform(-3.3, 3.3)  # Voltage range
            
        elif signal['signal_type'] == 'bus':
            # Bus signals - always random
            max_val = (2 ** signal['bitwidth']) - 1
            return random.randint(0, max_val)
            
        elif signal['signal_type'] == 'control':
            # Control signals - random values
            if signal['bitwidth'] == 1:
                # Binary control signals random
                return random.randint(0, 1)
            else:
                # Multi-bit control registers
                return random.randint(0, (2 ** signal['bitwidth']) - 1)
            
        else:
            # Data and address signals - always random
            if signal['var_type'] == 'integer':
                max_val = (2 ** 31) - 1
                min_val = -(2 ** 31)
                return random.randint(min_val, max_val)
            else:
                max_val = (2 ** signal['bitwidth']) - 1
                return random.randint(0, max_val)
            
    def write_initial_values(self):
        """Write initial values for all signals."""
        self.write_line("#0")
        self.write_line("$dumpvars")
        
        for signal in self.signals:
            if signal['var_type'] == 'real':
                value = 0.0
                self.write_line(f"r{value:.6g} {signal['id']}")
            elif signal['bitwidth'] == 1:
                value = 0
                self.write_line(f"{value}{signal['id']}")
            else:
                value = 0
                bin_str = format(value, f"0{signal['bitwidth']}b")
                self.write_line(f"b{bin_str} {signal['id']}")
                
            signal['last_value'] = value
            
        self.write_line("$end")
        
    def simulate(self):
        """Simulate the design for specified number of clock cycles."""
        # Base clock period: 1ns (1GHz)
        clock_period_ps = 1000
        
        print(f"Simulating {len(self.signals)} signals for {self.clock_count} cycles...")
        print("All signals will update every 1-100 clock cycles with different frequencies")
        
        for cycle in range(self.clock_count):
            time_ps = cycle * clock_period_ps
            
            changes = []
            
            # Update ALL signals based on their update interval
            for signal in self.signals:
                # Check if this signal should update this cycle
                if (cycle - signal['last_update_cycle']) >= signal['update_interval']:
                    new_value = self.calculate_signal_value(signal, time_ps)
                    
                    # Always force a value change for non-clock signals to maximize activity
                    attempts = 0
                    while not signal['is_clock'] and new_value == signal.get('last_value') and attempts < 10:
                        # Keep trying to get a different value
                        new_value = self.calculate_signal_value(signal, time_ps)
                        attempts += 1
                    
                    # If still the same after attempts, force a change
                    if not signal['is_clock'] and new_value == signal.get('last_value'):
                        if signal['var_type'] == 'real':
                            new_value = signal.get('last_value', 0) + random.uniform(0.1, 1.0)
                        elif signal['bitwidth'] == 1:
                            new_value = 1 - signal.get('last_value', 0)
                        else:
                            max_val = (2 ** signal['bitwidth']) - 1 if signal['bitwidth'] < 32 else 2**31-1
                            current = signal.get('last_value', 0)
                            new_value = (current + random.randint(1, max(1, max_val // 10))) % (max_val + 1)
                    
                    signal['last_value'] = new_value
                    signal['last_update_cycle'] = cycle
                    # Randomize next update interval for even more variation
                    signal['update_interval'] = random.randint(1, 100)
                    changes.append((signal, new_value))
                        
            # Write changes if any
            if changes:
                self.write_line(f"#{time_ps}")
                for signal, value in changes:
                    if signal['var_type'] == 'real':
                        self.write_line(f"r{value:.6g} {signal['id']}")
                    elif signal['bitwidth'] == 1:
                        self.write_line(f"{int(value)}{signal['id']}")
                    else:
                        if signal['var_type'] == 'integer' and value < 0:
                            # Two's complement for negative integers
                            unsigned_val = (1 << signal['bitwidth']) + int(value)
                            bin_str = format(unsigned_val, f"0{signal['bitwidth']}b")
                        else:
                            bin_str = format(int(value), f"0{min(signal['bitwidth'], 64)}b")
                        self.write_line(f"b{bin_str} {signal['id']}")
                        
    def generate(self):
        """Generate the complete VCD file."""
        try:
            self.open_file()
            print(f"Generating VCD file: {self.filename}")
            print(f"Target: 200K variables, {self.clock_count} clock cycles")
            
            self.write_header()
            self.write_signal_definitions()
            
            # Adjust if we didn't reach 200K variables
            if self.total_vars < 200000:
                print(f"Warning: Only created {self.total_vars} variables")
                # Could add more signals here if needed
                
            self.write_initial_values()
            print("Simulating design...")
            self.simulate()
            
            print(f"VCD file '{self.filename}' generated successfully!")
            print(f"Total variables: {self.total_vars}")
            print(f"Clock cycles: {self.clock_count}")
            print(f"Hierarchy depth: 10 levels")
            
        finally:
            self.close_file()


def main():
    """Main function to parse arguments and generate VCD."""
    parser = argparse.ArgumentParser(description='Generate a complex processor design VCD for benchmarking')
    parser.add_argument('-o', '--output', default='design_claude.vcd',
                       help='Output VCD filename (default: design_claude.vcd)')
    parser.add_argument('-c', '--clocks', type=int, default=10000,
                       help='Number of clock cycles to simulate (default: 10000)')
    
    args = parser.parse_args()
    
    generator = RISCDesignGenerator(filename=args.output, clock_count=args.clocks)
    generator.generate()


if __name__ == "__main__":
    main()
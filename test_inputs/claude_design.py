#!/usr/bin/env python3
"""
Generate a VCD file for a complex processor design with hierarchical structure.
Creates 1 million variables across 10 levels of nested scopes for benchmarking.
Generated by Claude for WaveScout performance testing.
"""

import math
import sys
import argparse
import random
from datetime import datetime


def encode_id(n):
    """Encode a number as a VCD identifier using printable ASCII characters."""
    chars = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    if n == 0:
        return chars[0]
    
    result = ""
    while n > 0:
        result = chars[n % len(chars)] + result
        n //= len(chars)
    return result


class RISCDesignGenerator:
    def __init__(self, filename="claude_design.vcd", clock_count=10000):
        self.filename = filename
        self.clock_count = clock_count
        self.file = None
        self.var_counter = 0
        self.total_vars = 0
        self.signals = []
        self.clock_signals = []  # Track clock signals for aliases
        self.signal_update_cycles = {}  # Track when each signal should update
        
    def open_file(self):
        """Open the VCD file for writing."""
        self.file = open(self.filename, 'w')
        
    def close_file(self):
        """Close the VCD file."""
        if self.file:
            self.file.close()
            
    def write_line(self, line=""):
        """Write a line to the VCD file."""
        if self.file:
            self.file.write(line + "\n")
        
    def write_header(self):
        """Write the VCD header section."""
        self.write_line("$date")
        self.write_line(f"    {datetime.now().strftime('%a %b %d %H:%M:%S %Y')}")
        self.write_line("$end")
        self.write_line("$version")
        self.write_line("    Claude Design VCD Generator for WaveScout Benchmarking")
        self.write_line("$end")
        self.write_line("$timescale")
        self.write_line("    1ps")
        self.write_line("$end")
        
    def generate_signal_name(self, prefix, index, signal_type):
        """Generate a meaningful signal name based on type."""
        suffixes = {
            'clock': ['clk', 'clock', 'sclk', 'mclk', 'pclk'],
            'data': ['data', 'd', 'din', 'dout', 'q'],
            'control': ['en', 'rst', 'valid', 'ready', 'ack'],
            'address': ['addr', 'adr', 'pc', 'sp', 'ptr'],
            'bus': ['bus', 'dbus', 'abus', 'ibus', 'xbus'],
            'analog': ['vdd', 'vss', 'vref', 'iout', 'temp']
        }
        
        suffix_list = suffixes.get(signal_type, ['sig'])
        suffix = suffix_list[index % len(suffix_list)]
        return f"{prefix}_{suffix}_{index}"
        
    def create_scope_signals(self, scope_path, level, max_vars_in_scope):
        """Create signals for a specific scope."""
        # Limit the number of variables per scope for performance
        vars_in_scope = min(max_vars_in_scope, 1000)  # Cap at 1000 per scope for efficiency
        
        if vars_in_scope < 10:
            vars_in_scope = 10  # Minimum signals per scope
            
        signals_created = []
        
        # Create mix of signal types
        signal_distribution = [
            ('clock', 0.05),    # 5% clocks
            ('data', 0.30),     # 30% data signals
            ('control', 0.15),  # 15% control signals
            ('address', 0.10),  # 10% address signals
            ('bus', 0.25),      # 25% buses
            ('analog', 0.15)    # 15% analog signals
        ]
        
        for sig_type, ratio in signal_distribution:
            count = int(vars_in_scope * ratio)
            if count == 0 and sig_type == 'clock':
                count = 1  # At least one clock per scope
                
            for i in range(count):
                sig_name = self.generate_signal_name(scope_path.replace('/', '_'), i, sig_type)
                sig_id = encode_id(self.var_counter)
                self.var_counter += 1
                
                # Determine signal properties based on type
                if sig_type == 'clock':
                    var_type = 'wire'
                    bitwidth = 1
                    # Different clock frequencies
                    freq_options = [1e9, 500e6, 250e6, 125e6, 100e6, 50e6, 25e6, 10e6]
                    frequency = freq_options[i % len(freq_options)]
                    is_clock = True
                elif sig_type == 'analog':
                    var_type = 'real'
                    bitwidth = 64
                    frequency = random.uniform(1e3, 1e6)  # Analog signal frequencies
                    is_clock = False
                elif sig_type == 'bus':
                    var_type = 'reg'
                    # Various bus widths
                    bus_widths = [8, 16, 32, 64, 128, 256]
                    bitwidth = bus_widths[i % len(bus_widths)]
                    frequency = random.uniform(1e6, 100e6)
                    is_clock = False
                elif sig_type == 'address':
                    var_type = 'reg'
                    bitwidth = 32  # Standard address width
                    frequency = random.uniform(10e6, 500e6)
                    is_clock = False
                else:  # data, control
                    var_type = random.choice(['reg', 'wire', 'integer'])
                    if var_type == 'integer':
                        bitwidth = 32
                    else:
                        bitwidth = random.choice([1, 2, 4, 8, 16, 32])
                    frequency = random.uniform(1e6, 1e9)
                    is_clock = False
                    
                # Write variable declaration
                self.write_line(f"$var {var_type} {bitwidth} {sig_id} {sig_name} $end")
                
                # Store signal info
                signal_info = {
                    'id': sig_id,
                    'name': sig_name,
                    'var_type': var_type,
                    'bitwidth': bitwidth,
                    'frequency': frequency,
                    'phase': random.uniform(0, 2 * math.pi),
                    'is_clock': is_clock,
                    'signal_type': sig_type,
                    'level': level,
                    'scope': scope_path,
                    'update_interval': random.randint(1, 20),  # Update every 1-20 clocks
                    'last_update_cycle': -1  # Track last update
                }
                
                signals_created.append(signal_info)
                self.signals.append(signal_info)
                
                if is_clock:
                    self.clock_signals.append(signal_info)
                    signal_info['update_interval'] = 1  # Clocks always update every cycle
                    
                self.total_vars += 1
                
        return signals_created
        
    def create_hierarchical_structure(self, current_scope, level, max_level, path="", remaining_vars=1000000):
        """Recursively create hierarchical module structure."""
        if level > max_level or remaining_vars <= 0:
            return remaining_vars
            
        # Module names based on typical RISC processor components
        module_types = [
            'core', 'alu', 'decoder', 'regfile', 'cache', 'mmu', 'fpu',
            'bpu', 'lsu', 'scheduler', 'rob', 'issue', 'fetch', 'execute',
            'memory', 'writeback', 'arbiter', 'controller', 'datapath', 'pipeline'
        ]
        
        # Calculate target variables per level to reach 1M total
        # Distribute more evenly to avoid creating too many at once
        if level == 1:
            vars_at_this_level = min(10000, remaining_vars // 10)  # Top level gets fewer
        else:
            vars_at_this_level = min(50000, remaining_vars // (11 - level))
        
        # Create signals in current scope
        prev_total = self.total_vars
        self.create_scope_signals(path if path else "top", level, vars_at_this_level)
        vars_created = self.total_vars - prev_total
        remaining_vars -= vars_created
        
        # Create child modules
        if level < max_level and remaining_vars > 0:
            # Number of child modules decreases with depth
            num_children = max(2, min(5, 7 - level))  # Limit children to control explosion
            
            for i in range(num_children):
                if remaining_vars <= 0:
                    break
                    
                module_type = module_types[(level * 10 + i) % len(module_types)]
                module_name = f"{module_type}_{level}_{i}"
                child_path = f"{path}/{module_name}" if path else module_name
                
                self.write_line(f"$scope module {module_name} $end")
                remaining_vars = self.create_hierarchical_structure(module_name, level + 1, max_level, child_path, remaining_vars)
                self.write_line("$upscope $end")
                
        return remaining_vars
                
    def create_clock_aliases(self):
        """Create aliases for clock signals to simulate clock distribution networks."""
        # Only create aliases for actual clock signals
        for i, clock_sig in enumerate(self.clock_signals[:100]):  # Limit aliases to prevent excessive duplication
            # Create 2-3 aliases per clock to simulate distribution
            num_aliases = random.randint(2, 3)
            for j in range(num_aliases):
                alias_id = encode_id(self.var_counter)
                self.var_counter += 1
                alias_name = f"{clock_sig['name']}_alias_{j}"
                
                # Use the same ID for the alias (pointing to same signal)
                self.write_line(f"$var {clock_sig['var_type']} {clock_sig['bitwidth']} {alias_id} {alias_name} {clock_sig['id']} $end")
                
    def write_signal_definitions(self):
        """Write all signal definitions with hierarchical structure."""
        self.write_line("$scope module top $end")
        
        # Create 10 levels of hierarchy with 1M target
        target_vars = 1000000  # Always target 1M variables for benchmarking
        self.create_hierarchical_structure("top", 1, 10, "", target_vars)
        
        # Add clock aliases at the top level (skip for now to speed up)
        # self.create_clock_aliases()
        
        self.write_line("$upscope $end")
        self.write_line("$enddefinitions $end")
        
        print(f"Created {self.total_vars} unique variables across 10 scope levels")
        print(f"Created {len(self.clock_signals)} clock signals")
        
    def calculate_signal_value(self, signal, time_ps):
        """Calculate signal value at given time."""
        time_sec = time_ps * 1e-12
        
        if signal['is_clock']:
            # Simple square wave for clocks
            period = 1.0 / signal['frequency']
            phase_time = time_sec + signal['phase'] / (2 * math.pi * signal['frequency'])
            return 1 if (phase_time % period) < (period / 2) else 0
            
        elif signal['var_type'] == 'real':
            # Analog signals - sine waves with some noise
            base = math.sin(2 * math.pi * signal['frequency'] * time_sec + signal['phase'])
            noise = random.uniform(-0.1, 0.1)
            return base * (1 + noise) * random.uniform(0.5, 3.3)  # Voltage range
            
        elif signal['signal_type'] == 'bus':
            # Bus signals - always change to simulate active bus traffic
            max_val = (2 ** signal['bitwidth']) - 1
            # Mix of random and incremental patterns
            if random.random() < 0.3:
                # Incremental pattern
                current = signal.get('last_value', 0)
                if isinstance(current, (int, float)):
                    return (int(current) + random.randint(1, 10)) % (max_val + 1)
            return random.randint(0, max_val)
            
        elif signal['signal_type'] == 'control':
            # Control signals - toggle or change based on time
            if signal['bitwidth'] == 1:
                # Binary control signals toggle
                return 1 - signal.get('last_value', 0)
            else:
                # Multi-bit control registers
                return random.randint(0, (2 ** signal['bitwidth']) - 1)
            
        else:
            # Data and address signals - always active with various patterns
            if signal['var_type'] == 'integer':
                max_val = (2 ** 31) - 1
                min_val = -(2 ** 31)
                # Mix of patterns: random, counting, bit patterns
                pattern = random.random()
                if pattern < 0.3:
                    # Counting pattern
                    current = signal.get('last_value', 0)
                    if isinstance(current, (int, float)):
                        return min(max_val, max(min_val, int(current) + random.randint(-100, 100)))
                elif pattern < 0.6:
                    # Bit pattern (powers of 2, etc)
                    return random.choice([0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, -1, -2, -4, -8])
                else:
                    return random.randint(min_val, max_val)
            else:
                max_val = (2 ** signal['bitwidth']) - 1
                # Various data patterns
                pattern = random.random()
                if pattern < 0.2:
                    # All zeros or all ones
                    return random.choice([0, max_val])
                elif pattern < 0.4:
                    # Walking ones/zeros
                    bit_pos = random.randint(0, signal['bitwidth'] - 1)
                    return 1 << bit_pos
                elif pattern < 0.6:
                    # Counting
                    current = signal.get('last_value', 0)
                    if isinstance(current, (int, float)):
                        return (int(current) + 1) % (max_val + 1)
                else:
                    return random.randint(0, max_val)
            
    def write_initial_values(self):
        """Write initial values for all signals."""
        self.write_line("#0")
        self.write_line("$dumpvars")
        
        for signal in self.signals:
            if signal['var_type'] == 'real':
                value = 0.0
                self.write_line(f"r{value:.6g} {signal['id']}")
            elif signal['bitwidth'] == 1:
                value = 0
                self.write_line(f"{value}{signal['id']}")
            else:
                value = 0
                bin_str = format(value, f"0{signal['bitwidth']}b")
                self.write_line(f"b{bin_str} {signal['id']}")
                
            signal['last_value'] = value
            
        self.write_line("$end")
        
    def simulate(self):
        """Simulate the design for specified number of clock cycles."""
        # Base clock period: 1ns (1GHz)
        clock_period_ps = 1000
        
        print(f"Simulating {len(self.signals)} signals for {self.clock_count} cycles...")
        print("All signals will update every 1-20 clock cycles for maximum activity")
        
        for cycle in range(self.clock_count):
            time_ps = cycle * clock_period_ps
            
            changes = []
            
            # Update ALL signals based on their update interval
            for signal in self.signals:
                # Check if this signal should update this cycle
                if (cycle - signal['last_update_cycle']) >= signal['update_interval']:
                    new_value = self.calculate_signal_value(signal, time_ps)
                    
                    # Always force a value change for non-clock signals to maximize activity
                    if not signal['is_clock'] and new_value == signal.get('last_value'):
                        # Force a different value
                        if signal['var_type'] == 'real':
                            new_value = random.uniform(-3.3, 3.3)
                        elif signal['bitwidth'] == 1:
                            new_value = 1 - signal.get('last_value', 0)
                        else:
                            max_val = (2 ** signal['bitwidth']) - 1 if signal['bitwidth'] < 32 else 2**31-1
                            new_value = random.randint(0, max_val)
                    
                    if new_value != signal.get('last_value'):
                        signal['last_value'] = new_value
                        signal['last_update_cycle'] = cycle
                        changes.append((signal, new_value))
                        
            # Write changes if any
            if changes:
                self.write_line(f"#{time_ps}")
                for signal, value in changes:
                    if signal['var_type'] == 'real':
                        self.write_line(f"r{value:.6g} {signal['id']}")
                    elif signal['bitwidth'] == 1:
                        self.write_line(f"{int(value)}{signal['id']}")
                    else:
                        if signal['var_type'] == 'integer' and value < 0:
                            # Two's complement for negative integers
                            unsigned_val = (1 << signal['bitwidth']) + int(value)
                            bin_str = format(unsigned_val, f"0{signal['bitwidth']}b")
                        else:
                            bin_str = format(int(value), f"0{min(signal['bitwidth'], 64)}b")
                        self.write_line(f"b{bin_str} {signal['id']}")
                        
    def generate(self):
        """Generate the complete VCD file."""
        try:
            self.open_file()
            print(f"Generating VCD file: {self.filename}")
            print(f"Target: 1 million variables, {self.clock_count} clock cycles")
            
            self.write_header()
            self.write_signal_definitions()
            
            # Adjust if we didn't reach 1M variables
            if self.total_vars < 1000000:
                print(f"Warning: Only created {self.total_vars} variables")
                # Could add more signals here if needed
                
            self.write_initial_values()
            print("Simulating design...")
            self.simulate()
            
            print(f"VCD file '{self.filename}' generated successfully!")
            print(f"Total variables: {self.total_vars}")
            print(f"Clock cycles: {self.clock_count}")
            print(f"Hierarchy depth: 10 levels")
            
        finally:
            self.close_file()


def main():
    """Main function to parse arguments and generate VCD."""
    parser = argparse.ArgumentParser(description='Generate a complex processor design VCD for benchmarking')
    parser.add_argument('-o', '--output', default='claude_design.vcd',
                       help='Output VCD filename (default: claude_design.vcd)')
    parser.add_argument('-c', '--clocks', type=int, default=10000,
                       help='Number of clock cycles to simulate (default: 10000)')
    
    args = parser.parse_args()
    
    generator = RISCDesignGenerator(filename=args.output, clock_count=args.clocks)
    generator.generate()


if __name__ == "__main__":
    main()